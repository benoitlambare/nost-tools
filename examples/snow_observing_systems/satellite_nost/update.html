<!DOCTYPE html>
<html>
    <head>
      <meta charset="utf-8">
    <title>Novel Observing Strategies Testbed (NOS-T)</title>
    <h1 style="text-align: center;">Novel Observing Strategies Testbed (NOS-T): FireSat+ Example</h1>
      <meta name="description" content="">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <link href="https://cesium.com/downloads/cesiumjs/releases/1.85/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
        <script type="text/javascript"
            src="env.js">
        </script>
    </head>

    <body>
        <main role="main" class="container-fluid">
            <div id="cesiumContainer" style="will-change: contents;"></div>
        </main>
        <script src="https://cesium.com/downloads/cesiumjs/releases/1.85/Build/Cesium/Cesium.js"></script>
        <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ho+j7jyWK8fNQe+A12Hb8AhRq26LrZ/JpcUGGOn+Y7RsweNrtN/tE3MoK7ZeZDyx" crossorigin="anonymous"></script>
        <script type="module">
            import { AMQPWebSocketClient } from './js/amqp-websocket-client.mjs';

            var CESIUM_ACCESS_TOKEN = TOKEN;
            var BROKER_HOST = HOST;
            var BROKER_PORT = RABBITMQ_PORT;
            var AUTH_PORT = KEYCLOAK_PORT;
            var BROKER_CLIENT_USERNAME = USERNAME;
            var BROKER_CLIENT_PASSWORD = PASSWORD;
            var BROKER_CLIENT_ID = CLIENT_ID;
            var BROKER_CLIENT_SECRET = CLIENT_SECRET;

            $(document).ready(function(){
                Cesium.Ion.defaultAccessToken = CESIUM_ACCESS_TOKEN;
                var clock = new Cesium.Clock({
                        currentTime: Cesium.JulianDate.fromIso8601("1900-01-01"),
                        clockStep: Cesium.ClockStep.SYSTEM_CLOCK_MULTIPLIER,
                        multiplier: 0, // how much time to advance each SYSTEM CLOCK tick
                        shouldAnimate: false,
                    });
                const viewer = new Cesium.Viewer('cesiumContainer', {
                    terrainProvider: Cesium.createWorldTerrain(),
                    baseLayerPicker: false,
                    homeButton: false,
                    infoBox: false,
                    geocoder: false,
                    selectionIndicator: false,
                    navigationHelpButton: false,
                    navigationInstructionsInitiallyVisible: false,
                    timeline: true,
                    imageryProvider: new Cesium.IonImageryProvider({ assetId: 3845 }),
                    clockViewModel: new Cesium.ClockViewModel(clock)
                });

                var satellites = {}; // Positions of satellites as points at altitude, BLUE out of comms range, GREEN in comms range
                var sensorCircles = {}; // Circles showing views of nadir pointed satellites
                var commsCones = {}; // Views from ground station FOR comms
                var commsRange = false; // Initialize this commsRange boolean as false, but will update based on satellite subscription
                var satColor = Cesium.Color.BLUE; // Initialize satColor as Cesium's default BLUE, which is color when commsRange is false
                var fires = viewer.scene.primitives.add(new Cesium.PointPrimitiveCollection()); // Initialize fires as primitive points since there will be so many
                var grounds = {}; // Surface position of ground stations as PINK points
                var updates = {};
                var trajectories = {}; // Store satellite trajectories
                var previousSensorCircles = {}; // Store previous sensor circles for each satellite
                var previousLabelEntities = {}; // Store previous label entities for each satellite
                var polylineEntities = {}; // Store polyline entities for each satellite

                function handleMessage(topic, payload) {
                    var activeCheck; // Declare activeCheck variable
                    var commRange; // Declare commRange variable
                    var groundColor; // Declare groundColor variable
                    var groundMaterial; // Declare groundMaterial variable
                    var satColor; // Declare satColor variable
                    var fireColor; // Declare fireColor variable
                    var fireMaterial; // Declare fireMaterial variable
                    var fireId; // Declare fireId variable
                    var groundId; // Declare groundId variable
                    var id; // Declare id variable
                    var latitude; // Declare latitude variable
                    var longitude; // Declare longitude variable
                    var name; // Declare name variable
                    var color; // Declare color variable

                    // try to parse and stringify a JSON string
                    try {
                        if(topic=="greenfield.manager.init") {
                            console.log("Initialize command received.");
                            viewer.clockViewModel.currentTime = Cesium.JulianDate.fromIso8601(payload.taskingParameters.simStartTime);
                            viewer.clockViewModel.startTime = Cesium.JulianDate.fromIso8601(payload.taskingParameters.simStartTime);
                            viewer.clockViewModel.stopTime = Cesium.JulianDate.fromIso8601(payload.taskingParameters.simStopTime);
                            viewer.clockViewModel.clockRange = Cesium.ClockRange.CLAMPED;
                            viewer.timeline.zoomTo(viewer.clockViewModel.startTime,viewer.clockViewModel.stopTime);
                        } else if(topic=="greenfield.manager.start") {
                            console.log("Start command received.");
                            viewer.clockViewModel.multiplier = payload.taskingParameters.timeScalingFactor;
                        } else if(topic=="greenfield.manager.time" || topic=="greenfield.manager.status.time") {
                            // console.log("Time message received.");
                            viewer.clockViewModel.currentTime = Cesium.JulianDate.fromIso8601(payload.properties.simTime);
                            viewer.timeline.updateFromClock();
                        } else if(topic=="greenfield.manager.update"){
                            // console.log("Update message received.");
                            viewer.clockViewModel.multiplier = payload.taskingParameters.timeScalingFactor;
                        } else if(topic=="greenfield.constellation.location") {
                            console.log("Satellite location received.");
                            console.log(payload);
                            commRange = payload.commRange;
                            if (commRange){
                                satColor = Cesium.Color.GREEN
                            } else {
                                satColor = Cesium.Color.BLUE
                            };

                            const position = Cesium.Cartesian3.fromDegrees(payload.longitude, payload.latitude, payload.altitude);
                            const altitude_km = payload.altitude / 1000;
                            const radius_km = payload.radius / 1000;

                            if (!trajectories[payload.id]) {
                                trajectories[payload.id] = [];
                            }

                            // Check if the new position is different from the last position
                            const lastPosition = trajectories[payload.id][trajectories[payload.id].length - 1];
                            if (!lastPosition || !Cesium.Cartesian3.equals(position, lastPosition)) {
                                trajectories[payload.id].push(position);
                            }

                            // Remove previous sensor circles
                            if (previousSensorCircles[payload.id]) {
                                previousSensorCircles[payload.id].forEach(circle => {
                                    viewer.scene.primitives.remove(circle);
                                });
                                previousSensorCircles[payload.id].length = 0;
                            }

                            // Remove previous label entity
                            if (previousLabelEntities[payload.id]) {
                                viewer.entities.remove(previousLabelEntities[payload.id]);
                            }

                            // Add current position as red point with label
                            previousLabelEntities[payload.id] = viewer.entities.add({
                                position: position,
                                point: {
                                    pixelSize: 10,
                                    color: Cesium.Color.RED
                                },
                                label: {
                                    text: `{name: ${payload.name},\nlatitude: ${payload.latitude.toFixed(6)},\nlongitude: ${payload.longitude.toFixed(6)},\naltitude: ${altitude_km.toFixed(2)} km,\nradius: ${radius_km.toFixed(2)} km,\nstate: ${payload.state}\ntime: ${payload.time}}`,
                                    font: '10pt Arial',
                                    style: Cesium.LabelStyle.FILL, // Cesium.LabelStyle.FILL_AND_OUTLINE,
                                    fillColor: Cesium.Color.WHITE,
                                    // outlineWidth: 5,
                                    verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                                    pixelOffset: new Cesium.Cartesian2(0, -15),
                                    eyeOffset: new Cesium.Cartesian3(0, 0, -5000), // Add this line to make the label the top-most layer
                                    showBackground: true, // Show background box
                                    backgroundColor: Cesium.Color.BLACK.withAlpha(0.7) // Set background color with transparency
                                }
                            });

                            // Add current sensor radius as red circle
                            const sensorRadius = payload.radius;
                            const currentSensorCircle = new Cesium.CircleGeometry({
                                center: position,
                                radius: sensorRadius,
                                vertexFormat: Cesium.PerInstanceColorAppearance.VERTEX_FORMAT
                            });

                            const currentSensorCircleInstance = new Cesium.GeometryInstance({
                                geometry: currentSensorCircle,
                                attributes: {
                                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.RED.withAlpha(0.3))
                                }
                            });

                            const currentPrimitive = new Cesium.Primitive({
                                geometryInstances: currentSensorCircleInstance,
                                appearance: new Cesium.PerInstanceColorAppearance()
                            });

                            viewer.scene.primitives.add(currentPrimitive);

                            // Store the current sensor circle primitive for future removal
                            if (!previousSensorCircles[payload.id]) {
                                previousSensorCircles[payload.id] = [];
                            }
                            previousSensorCircles[payload.id].push(currentPrimitive);

                            // Remove previous polyline entity
                            if (polylineEntities[payload.id]) {
                                viewer.entities.remove(polylineEntities[payload.id]);
                            }

                            // Add polyline to indicate the satellite's path
                            polylineEntities[payload.id] = viewer.entities.add({
                                polyline: {
                                    positions: trajectories[payload.id],
                                    width: 2,
                                    material: Cesium.Color.YELLOW
                                }
                            });
                        }
                    } catch(err) {
                        console.log(`ERROR: ${err}`) //'An error was caught somewhere...')
                    }
                }

                const url = `ws://${BROKER_HOST}:${BROKER_PORT}`;
                fetch(`${BROKER_HOST.includes("localhost") ? "http" : "https"}://${BROKER_HOST}:${AUTH_PORT}/realms/test/protocol/openid-connect/token`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    body: new URLSearchParams({
                        'client_id': BROKER_CLIENT_ID,
                        'client_secret': BROKER_CLIENT_SECRET,
                        'grant_type': 'client_credentials'
                    })
                }).then(response => {
                    if (response.ok) {
                        return response.json();
                    } else {
                        throw new Error('Failed to obtain access token');
                    }
                }).then(data => {
                    console.log("Access token obtained.");
                    const accessToken = data.access_token;
                    const amqp = new AMQPWebSocketClient(url, "/", "", accessToken);
                    async function start(amqp) {
                        try {
                            const conn = await amqp.connect();
                            const ch = await conn.channel();
                            await ch.exchangeDeclare("greenfield", "topic", {durable: true, autoDelete: false});
                            const q = await ch.queue("greenfield.#");
                            await q.bind("greenfield", "greenfield.#");
                            const consumer = await q.subscribe({noAck: false}, (msg) => {
                                const topic = msg.routingKey;
                                const payload = JSON.parse(msg.bodyToString());
                                handleMessage(topic, payload);
                                msg.ack();
                            })
                        } catch (err) {
                            console.error("Error", err, "reconnecting in 1s");
                            // setTimeout(() => start(amqp), 1000);
                        }
                    }
                    start(amqp);
                }).catch(error => {
                    console.error(error);
                });
            });
        </script>
    </body>
</html>